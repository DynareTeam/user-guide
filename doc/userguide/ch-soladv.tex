\chapter{Solving DSGE models - advanced topics} \label{ch:soladv}

This chapter is a collection of topics - not all related to each other - that you will probably find interesting or at least understandable, if you have read the earlier Chapter \ref{ch:solbase} on the basics of solving DSGE models. This chapter begins with a section covering the methodologies used by Dynare to solve DSGE models. It then includes a section on undertaking more advanced or custom features in Dynare, like running loops to compare impulse response functions on the same graph, or retrieving particular series of data from your output files. Finally, the chapter ends with a section on modeling tips optimized for Dynare, but possibly also helpful for other work.\\

\section{Behind the scenes: an intro to solving stochastic DSGE models}
The aim of this section is to peer behind the scenes of Dynare, or under its hood, to get an idea of the methodologies and algorithms used in its computations. Going into details would be beyond the scope of this User Guide which will instead remain at a high level. What you will find below will either comfort you in realizing that Dynare does what you expected of it - and what you would have also done if you had had to code it all yourself (with ten extra years of life expectancy and a direct phone line to the Dynare development team!), or will spur your curiosity to have a look at more detailed material. If so, you may want to go through Michel Juillard's presentation on solving DSGE models to a first and second order (** add link), or read \citet{CollardJuillard2001b} or \citet{SchmittGrohe2004} which gives a good overview of the most recent techniques based on perturbation methods. \\

\subsection{What is the advantage of a second order approximation?}
As noted in chapter \ref{ch:solbase} and as will become clear in the section below, linearizing a system of equations to the first order raises the issue of certainty equivalence. This is because only the first moments of the shocks enter the linearized equations, and when expectations are taken, they disappear. Thus, unconditional expectations of the endogenous variables are equal to their non-stochastic steady state values. \\

This may be an acceptable simplification to make. But depending on the context, it may instead be quite misleading. For instance, when using second order welfare functions to compare policies, you also need second order approximations of the policy function. Yet more clearly, in the case of asset pricing models, linearizing to the second order enables you to take risk (or the variance of shocks) into consideration - a highly desirable modeling feature. It is therefore very convenient that Dynare allows you to choose between a first or second order linearization of your model in the option of the \texttt{stoch\_simul} command. \\

\subsection{How does dynare solve stochastic DSGE models?}
In this section, we shall briefly overview the perturbation methods employed by Dynare to solve DSGE models to a first order approximation. The second order follows very much the same approach, although at a higher level of complexity. The summary below is taken in most part from Michel Juillard's presentation ``Computing first order approximations of DSGE models with Dynare'' (** add link), which you should read if interested in particular details. \\

To summarize, a DSGE model is a collection of first order and equilibrium conditions that take the general form: 
\[
\mathbb{E}_t\left\{f(y_{t+1},y_t,y_{t-1},u_t)\right\}=0
\]
\begin{eqnarray*}
\mathbb{E}(u_t) &=& 0\\
\mathbb{E}(u_t u_t') &=& \Sigma_u
\end{eqnarray*}
and where:
\begin{description}
  \item[$y$]: vector of endogenous variables
  \item[$u$]: vector of exogenous stochastic shocks
\end{description}

The solution to this system is a set of equations relating variables in the current period to the past state of the system and current shocks, that satisfy the original system. This is what we call the policy function. Sticking to the above notation, we can this function as:
\[
y_t = g(y_{t-1},u_t)
\]

Then, it is straightforward to re-write $y_{t+1}$ as
\begin{eqnarray*}
  y_{t+1} &=& g(y_t,u_{t+1})\\
  &=& g(g(y_{t-1},u_t),u_{t+1})\\
\end{eqnarray*}

We can then define a new function $F$, such that:
\[
F(y_{t-1},u_t,u_{t+1}) =
f(g(g(y_{t-1},u_t),u_{t+1}),g(y_{t-1},u_t),y_{t-1},u_t)\\
\]
which enables us to rewrite our system in terms of past variables, and current and future shocks:
\[
\mathbb{E}_t\left[F(y_{t-1},u_t,u_{t+1})\right] = 0
\]

We then venture to linearize this model around a steady state defined as:
\[
f(\bar y, \bar y, \bar y) = 0
\]
having the property that:
\[
\bar y = g(\bar y, 0)
\]

The first order Taylor expansion around $\bar y$ yields:
\begin{eqnarray*}
\lefteqn{\mathbb{E}_t\left\{F^{(1)}(y_{t-1},u_t,u_{t+1})\right\} =}\\
&& \mathbb{E}_t\Big[f(\bar y, \bar y, \bar y)+f_{y_+}\left(g_y\left(g_y\hat y+g_uu \right)+g_u u' \right)\\
&& + f_{y_0}\left(g_y\hat y+g_uu \right)+f_{y_-}\hat y+f_u u\Big]\\
&& = 0
\end{eqnarray*}
with $\hat y = y_{t-1} - \bar y$, $u=u_t$, $u'=u_{t+1}$, $f_{y_+}=\frac{\partial f}{\partial y_{t+1}}$, $f_{y_0}=\frac{\partial f}{\partial y_t}$, $f_{y_-}=\frac{\partial f}{\partial y_{t-1}}$, $f_{u}=\frac{\partial f}{\partial u_t}$, $g_y=\frac{\partial g}{\partial y_{t-1}}$, $g_u=\frac{\partial g}{\partial u_t}$.\\

Taking expectations (we're almost there!):
\begin{eqnarray*}
   \lefteqn{\mathbb{E}_t\left\{F^{(1)}(y_{t-1},u_t, u_{t+1})\right\} =}\\
&& f(\bar y, \bar y, \bar y)+f_{y_+}\left(g_y\left(g_y\hat y+g_uu \right) \right)\\
&& + f_{y_0}\left(g_y\hat y+g_uu \right)+f_{y_-}\hat y+f_u u\Big\}\\
&=& \left(f_{y_+}g_yg_y+f_{y_0}g_y+f_{y_-}\right)\hat y+\left(f_{y_+}g_yg_u+f_{y_0}g_u+f_{u}\right)u\\
&=& 0\\
\end{eqnarray*}

As you can see, since future shocks only enter with their first moments (which are zero in expectations), they drop out when taking expectations of the linearized equations. This is technically why certainty equivalence holds in a system linearized to its first order. The second thing to note is that we have two unknown variables in the above equation: $g_y$ and $g_u$ each of which will help us recover the policy function $g$. \\

Since the above equation is true if the first and second parentheses are each zero, we can take each at a time (** hmm?). The first, yields a quadratic equation  in $g_y$, which we can solve with a series of algebraic trics that are not all immediately apparent (but detailed in Michel Juillard's presentation). Incidentally, one of the conditions that comes out of the solution of this equation is the Blanchard-Kahn condition: there must be as many roots larger than one in modulus as there are forward-looking variables in the model. Having recovered $g_y$, recovering $g_u$ is then straightforward from the second parenthesis. \\

Finally, notice that a first order linearization of the function $g$ yields:
\[
y_t = \bar y+g_y\hat y+g_u u
\]
And now that we have $g_y$ and $g_u$, we have solved for the (approximate) policy (or decision) function and have succeeded in solving our DSGE model. If we were interested in impulse response functions, for instance, we would simply iterate the policy function starting from an initial value given by the steady state. \\

The second order solution uses the same ``perturbation methods'' as above (the notion of starting from a function you can solve - like a steady state - and iterating forward), yet applies more complex algebraic techniques to recover the various partial derivatives of the policy function. But the general approach is perfectly isomorphic. Note that in the case of a second order approximation of a DSGE model, the variance of future shocks remains after taking expectations of the linearized equations and therefore affects the level of the resulting policy function.\\

\section{Advanced topics and functions in Dynare}
This section lists some of the more popular customizations of Dynare or advanced features that users may be interested in. 

\subsection{Finding and saving your output}
Where is output stored? ** TBD, add a table summarizing what results exist and where they are stored in version 4. \\

To save the data after simulations, you can just type: \texttt{save $<$datafilename$>$ $<$list of observed variables$>$} at the end of your .mod file. (** should the variables have the same name as in the .mod file?)

\subsection{Using loops to compare IRFs on the same graph}
** See irf\_loop.mod e.g.

\subsection{Referring to external files}
You may find it convenient to refer to an external file, either when computing the steady state of a model in Matlab and reading the values into a .mod file, or when specifying shocks in an external file. The former used to be convenient in Dynare version 3, but is no longer necessary in version 4; we therefore do not provide details. (** give some details anyhow? describe how version 4 deals with steady states of non-stationary variables?) But you may find the latter helpful, for instance, to simulate a model based on shocks from a prior estimation. You could then retrieve the exogenous shocks from the oo\_ file by saving them in a file called datafile.mat. Finally, you could simulate a deterministic model with the shocks saved from the estimation by specifying the source file for the shocks, using the \texttt{shocks(shocks\_file = datafile.mat)} command. (** how should the variables be ordered in this datafile?)
On the other hand, you could use the built-in commands in Dynare to generate impulse response functions from estimated shocks, as described in Chapter \ref{ch:estbase}. \\

\section{Modeling tips}

\subsection{Expectations taken in the past}
For instance, to enter the term $\mathbb{E}_{t-1}y_t$, define $s_t=\mathbb{E}_t[y_{t+1}]$ and then use $s(-1)$ in your .mod file.

\subsection{Stationarizing your model}
Models in Dynare must be stationary, such that you can linearize them around a steady state and return to steady state after a shock. Thus, you must first stationarize your model, then linearize it, either by hand, or by letting Dynare do the work.  You can then reconstruct ex-post the non-stationary simulated variables after running impulse response functions.\\

For deterministic models, the trick is to use only stationary variables in $t+1$. More generally, if $y_t$ is $I(1)$, you can always write $y_{t+1}$ as $y_t+dy_{t+1}$, where $dy_t= y_t-y_{t-1}$. Of course, you need to know the value of $dy_t$ at the final equilibrium.\\

Note that in a stationary model, it is expected that variables will eventually go back to steady state after the initial shock. If you expect to see a growing curve for a variable, you are thinking about a growth model. Because growth models are nonstationary, it is easier to work with the stationarized version of such models. Again, if you know the trend, you can always add it back after the simulation of the stationary components of the variables. 

\subsection{Infinite sums}
Dynare cannot deal with infinite sums very well. For instance, a user was once interested in entering 
\[
y_t=\sum_{j=0}^{\infty} \mathbb{E}_{t-j}x_t
\]
where $y_t$ and $x_t$ are endogenous variables. \\

In Dynare, the best way to handle this is to write out the first $k$ terms explicitly and enter each one in Dynare, such as: $\mathbb{E}_{t-1}x_t + \mathbb{E}_{t-2}x_t+\ldots + \mathbb{E}_{t-k}x_t$.
